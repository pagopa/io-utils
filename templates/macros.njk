{## 
 # used when we want to export the main type / const from its own module file
 #}
{% macro exportConst(defaultValue, type, typedef, quote = false) %}
  {{- 'import * as t from "io-ts";' | addImport -}}
  {% if defaultValue !== undefined %}
    {{- 'import { withDefault } from "italia-ts-commons/lib/types";' | addImport -}}
    {% set baseTypeName = type + "Base" %}
    export type {{ type }} = t.TypeOf<typeof {{ baseTypeName }}>;
    const {{ baseTypeName }} = {{ typedef | safe }};
    {% set q = '"' if quote else "" %}
    export const {{ type }} = withDefault({{ baseTypeName }}, {{ q | safe }}{{ defaultValue }}{{ q | safe }} as {{ type }});
  {% else %}
    export type {{ type }} = t.TypeOf<typeof {{ type }}>;
    export const {{ type }} = {{ typedef | safe }};
  {% endif %}
{% endmacro %}

{##
 # used when we want to define a properties of an object 
 # which is not exported in its own file / type (inlined)
 #}
{% macro inlineConst(defaultValue, type, typedef, quote = false) %}
  {% if defaultValue !== undefined %}
    {{- 'import { withDefault } from "italia-ts-commons/lib/types";' | addImport -}}
    {% if not (typedef | startsWith("t.")) %}
      {# create a type alias to set a default value #}
      {# this is mandatory as we need to cast the default value to this type #}
      {% set typeName = type | capitalize | camelCase %}
      {% set baseTypeName = typeName + "Base" %}
      {% set typeAlias %}t.TypeOf<typeof {{ baseTypeName }}>{% endset %}
      {% set typeAliasExport %}
        type {{ typeName | safe }} = {{ typeAlias | safe }};
        const {{ baseTypeName | safe }} = {{ typedef | safe }};
      {% endset %}
      {{- typeAliasExport | addTypeAlias -}}
    {% else %}
      {# if it is a primitive io-ts type, avoid create an alias #}
      {% set typeName %}t.TypeOf<typeof {{ typedef }}>{% endset %}
    {% endif %}
    {% set q = '"' if quote else "" %}
    withDefault({{ typedef | safe }}, {{ q | safe }}{{ defaultValue }}{{ q | safe }} as {{ typeName | safe }}),
  {% else %}
    {{ typedef | safe }},
  {% endif %}
{% endmacro %}

{## 
 # convenience method used to choose between export or inlining a type definition
 #}
{% macro defineConst(defaultValue, type, typedef, quote = false, inline = false) -%}
  {% if inline -%}
    {{ inlineConst(defaultValue, type, typedef, quote) }}
  {% else %}
    {{ exportConst(defaultValue, type, typedef, quote) }}
  {% endif -%}
{% endmacro -%}

{## 
 # convenience method used to import required modules
 # at the beginning of the type definition file
 #}
{% macro importLocalProp(realPropName) -%}
  {% set import -%}import { {{ realPropName }} } from "./{{ realPropName }}";{% endset -%}
  {{- import | addImport -}}
{% endmacro %}

{## 
 # defines an integer (or float) property with constraints
 #}
{% macro defineInteger(definitionName, definition, inline = false) -%}
  {% if definition.minimum and definition.maximum %}
    {{- 'import { WithinRangeNumber } from "italia-ts-commons/lib/numbers";' | addImport -}}
    {% set typedef %}WithinRangeNumber({{ definition.minimum }}, {{ definition.maximum }}){% endset %}
  {% elif definition.minimum == "0" %}
    {{- 'import { NonNegativeNumber } from "italia-ts-commons/lib/numbers";' | addImport -}}
    {% set typedef %}NonNegativeNumber{% endset %}
  {% else %}
    {% set typedef %}t.number{% endset %}
  {% endif %}
  {{ defineConst(definition.default, definitionName, typedef, false, inline) }}
{% endmacro -%}

{## 
 # defines a string property with constraints
 #}
{% macro defineString(definitionName, definition, inline = false) -%}
    {% if definition.pattern %}
      {{- 'import { PatternString } from "italia-ts-commons/lib/strings";' | addImport -}}
      {% set typedef %}PatternString("{{ definition.pattern | safe }}"){% endset %}
    {% elif definition.minLength and definition.maxLength %}
      {{- 'import { WithinRangeString } from "italia-ts-commons/lib/strings";' | addImport -}}
      {% set typedef %}WithinRangeString({{ definition.minLength }}, {{ definition.maxLength }}){% endset %}
    {% elif definition.minLength == 1 %}
      {{- 'import { NonEmptyString } from "italia-ts-commons/lib/strings";' | addImport -}}
      {% set typedef %}NonEmptyString{% endset %}
    {% elif definition.format == "email" %}
      {{- 'import { EmailString } from "italia-ts-commons/lib/strings";' | addImport -}}
      {% set typedef %}EmailString{% endset %}
    {% elif definition.format == "date-time" %}
      {{- 'import { DateFromString } from "italia-ts-commons/lib/dates";' | addImport -}}
      {% set typedef %}DateFromString{% endset %}
    {% elif definition["x-extensible-enum"] %}
      {{- 'import { enumType } from "italia-ts-commons/lib/types";' | addImport -}}
      {% set enumTypeAlias %}
        export enum {{ definitionName }}Enum {
            {% for enum in definition["x-extensible-enum"] %}
              "{{ enum }}" = "{{ enum }}",
            {% endfor %}
        }
      {% endset %}
      {{- enumTypeAlias | addTypeAlias -}}
      {% set typedef %}enumType<{{ definitionName }}Enum>(
        {{ definitionName }}Enum,
        "{{ definitionName }}"
      ){% endset %}
    {% else %}
      {% set typedef %}t.string{% endset %}
    {% endif %}
    {{ defineConst(definition.default, definitionName, typedef, true, inline) }}
{% endmacro %}

{## 
 # defines a boolean property
 #}
{% macro defineBoolean(definitionName, definition, inline = false) -%}
  {% set typedef %}t.boolean{% endset %}
  {{ defineConst(definition.default, definitionName, typedef, false, inline) }}
{% endmacro %}

{## 
 # defines a $ref property
 #}
{% macro defineRef(definitionName, definition, inline = false) -%}
  {% set typedef %}{{ definitionName | replace("#/definitions/", "") }}{% endset %}
  {{ defineConst(definition.default, typedef, typedef, false, inline) }}
{% endmacro %}

{## 
 # defines an object sub-property
 #}
{% macro defineSubObject(parentPropName, definitionName, definition) -%}
  {% set typedef %}{{ parentPropName }}{{ definitionName | capitalizeFirst }}{% endset %}
  {{ defineConst(definition.default, definitionName, typedef, false, true) }}
{% endmacro %}

{## 
 # defines an array property
 #}
{% macro defineArray(definitionName, definition, inline = false) -%}
  {{- 'import * as t from "io-ts";' | addImport -}}
  {% if definition.items.$ref %}
    {%- set realPropName = definition.items.$ref | replace("#/definitions/", "") -%}
    {{ importLocalProp(realPropName) }}
    {% set typedef %}t.readonlyArray({{ realPropName }}, "array of {{ realPropName }}"){% endset %}
  {% else %}
    {%- set realPropName = definition.items.type | replace("integer", "number") -%}
    {% set typedef %}t.readonlyArray(t.{{ realPropName }}, "array of {{ realPropName }}"){% endset %}
  {% endif %}
  {{ defineConst(definition.default, definitionName, typedef, false, inline) }}
{% endmacro %}

{## 
 # defines an object property of some prop.type
 #}
{% macro defineObjectProperty(propName, prop, parentPropName) -%}
  {% if propName %}
    "{{ propName }}":
  {% endif %}
  {%- if prop.$ref %}
    {{ defineRef(prop.$ref, prop, true) }}
  {% elif prop.type == "object" %}
    {{ defineSubObject(parentPropName, propName, prop) }}
  {% elif prop.type == "array" %}
    {{ defineArray(propName, prop, true) }}
  {% elif prop.type == "integer" or prop.type == "number" %}
    {{ defineInteger(propName, prop, true) }}
  {% elif prop.type == "string" %}
    {{ defineString(propName, prop, true) }}
  {% elif prop.type == "boolean" %}
    {{ defineBoolean(propName, prop, true) }}
  {% else %}
    // TODO: generate model for definition "{{ propName }}: {{ prop.type }}"
  {% endif %}
{% endmacro %}

{## 
 # convenience method to import required modules from $ref pointers
 #}
{% macro importLocalProps(definition) -%}
  {% set defaultFound = 0 %}
  {% for propName, prop in definition.properties -%}{%
    if prop.$ref -%}{%-
      set realPropName = prop.$ref | replace("#/definitions/", "") -%}
      {{ importLocalProp(realPropName) }}{%
    elif prop.items.$ref -%}{%-
      set realPropName = prop.items.$ref | replace("#/definitions/", "") -%}
      {{ importLocalProp(realPropName) }}{%
    endif %}{%
  endfor %}
  {% if definition.additionalProperties.$ref -%}{%-
      set realPropName = definition.additionalProperties.$ref | replace("#/definitions/", "") -%}
      {{ importLocalProp(realPropName) }}{%
    elif definition.additionalProperties.items.$ref -%}{%-
      set realPropName = definition.additionalProperties.items.$ref | replace("#/definitions/", "") -%}
      {{ importLocalProp(realPropName) }}{%
  endif %}
  {% for propName, prop in definition.properties -%}
    {% if prop.default !== undefined %}
      {{- 'import { withDefault } from "italia-ts-commons/lib/types";' | addImport -}}
    {% endif %}
  {% endfor %}
{% endmacro -%}

{## 
 # define object properties recursively,
 # supports additionaProperties, allOf and oneOf.
 #}
{% macro defineObject(definitionName, definition, strictInterfaces) -%}
  {{ importLocalProps(definition) }}
  {%- if definition.description %}
    {{ definition.description | comment | safe }}
  {% endif -%}

  {% if definition.type == "object" %}

    {{- 'import * as t from "io-ts";' | addImport -}}

    {% for propName, prop in definition.properties -%}
      {% if prop.type == "object" %}
        {{ defineObject(definitionName + propName, prop, strictInterfaces) }}
      {% endif %}
    {% endfor %}

    {% if definition.additionalProperties %}
      // additional attributes
      {% if definition.additionalProperties == true %}
        export const {{ definitionName }} = t.dictionary(
          t.string,
          t.any,
          "{{ definitionName }}"
        );
      {% else %}
        const {{ definitionName }}A = {{ defineObjectProperty(false, definition.additionalProperties) }}
        export const {{ definitionName }} = t.dictionary(
          t.string,
          {{ definitionName }}A,
          "{{ definitionName }}"
        );
      {% endif %}
    {% else %}
      // required attributes
      const {{ definitionName }}R = t.interface({
      {% for propName, prop in definition.properties -%}
        {% if definition.required and (definition.required | contains(propName)) %}
          {{ defineObjectProperty(propName, prop, definitionName) }}
        {% endif %}
      {% endfor %}
      });

      // optional attributes
      const {{ definitionName }}O = t.partial({
      {% for propName, prop in definition.properties -%}
        {% if (not definition.required) or (definition.required and not (definition.required | contains(propName))) %}
          {{ defineObjectProperty(propName, prop, definitionName) }}
        {% endif %}
      {% endfor %}
      });

      export const {{ definitionName }} = {% if strictInterfaces %}t.exact({% endif %} 
        t.intersection(
        [
          {{ definitionName }}R,
          {{ definitionName }}O
        ],
        "{{ definitionName }}"
      ) {% if strictInterfaces %}){% endif %};
    {% endif %}

    export type {{ definitionName }} = t.TypeOf<typeof {{ definitionName }}>;

  {% elif definition.allOf and not definition["x-one-of"] %}

    {% for schema in definition.allOf -%}
      {% if schema.type == "object" %}
        {{ defineObject(definitionName + loop.index, schema, strictInterfaces) }}
      {% elif schema.$ref %}
        {%- set realPropName = schema.$ref | replace("#/definitions/", "") -%}
        {{ importLocalProp(realPropName) }}
      {% endif %}
    {% endfor %}

    export const {{ definitionName }} = 
      t.intersection([
        {% for schema in definition.allOf -%}
          {% if schema.type == "object" %}
            {{ definitionName + loop.index }},
          {% elif schema.$ref %}
            {{ schema.$ref | replace("#/definitions/", "") }},
          {% endif %}
        {% endfor %}
      ],
      "{{ definitionName }}"
    );

    export type {{ definitionName }} = t.TypeOf<typeof {{ definitionName }}>;

  {# When using the custom property "x-one-of" allOf behaves like oneOf #}
  {# Needed to support swagger specs 2.0 that don't support oneOf #}
  {% elif definition.oneOf or (definition["x-one-of"] and definition.allOf) %}
    {% set oneOfProps = definition.oneOf if definition.oneOf else definition.allOf %}

    {% for schema in oneOfProps -%}
      {% if schema.type == "object" %}
        {{ defineObject(definitionName + loop.index, schema, strictInterfaces) }}
      {% elif schema.$ref %}
        {%- set realPropName = schema.$ref | replace("#/definitions/", "") -%}
        {{ importLocalProp(realPropName) }}
      {% endif %}
    {% endfor %}

    export const {{ definitionName }} = 
      t.union([
        {% for schema in oneOfProps -%}
          {% if schema.type == "object" %}
            {{ definitionName + loop.index }},
          {% elif schema.$ref %}
            {{ schema.$ref | replace("#/definitions/", "") }},
          {% endif %}
        {% endfor %}
      ],
      "{{ definitionName }}"
    );

    export type {{ definitionName }} = t.TypeOf<typeof {{ definitionName }}>;

  {% elif definition.type == "integer" or definition.type == "number" %}

    {{ defineInteger(definitionName, definition) }}

  {% elif definition.type == "string" %}

    {{ defineString(definitionName, definition) }}

  {% elif definition.type == "boolean" %}

    {{ defineBoolean(definitionName, definition) }}

  {% elif definition.type == "array" %}

    {{ defineArray(definitionName, definition) }}

  {% else %}

    // TODO: generate model for definition "{{ definitionName }}: {{ prop.type }}"

  {% endif %}
{% endmacro -%}
