// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`gen-api-models should generate a dictionary from additionalProperties: additional-properties 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTest = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalPropsTest\\"
);

export type AdditionalPropsTest = t.TypeOf<typeof AdditionalPropsTest>;
"
`;

exports[`gen-api-models should generate a dictionary from additionalProperties: true: additional-properties-true 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTrueTest = t.dictionary(
  t.string,
  t.any,
  \\"AdditionalPropsTrueTest\\"
);

export type AdditionalPropsTrueTest = t.TypeOf<typeof AdditionalPropsTrueTest>;
"
`;

exports[`gen-api-models should generate a module with all definitions 1`] = `
"// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// tslint:disable:max-union-size
// tslint:disable:no-identical-functions

import * as t from \\"io-ts\\";

import * as r from \\"italia-ts-commons/lib/requests\\";

/****************************************************************
 * testAuthBearer
 */

// Request type definition
export type TestAuthBearerT = r.IGetApiRequestType<
  {
    readonly bearerToken: string;
    readonly qo?: string;
    readonly qr: string;
    readonly cursor?: string;
  },
  \\"Authorization\\",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<403, undefined, never>
>;

export const testAuthBearerDefaultResponses = {
  200: t.undefined,
  403: t.undefined
};

export type TestAuthBearerResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = undefined,
  C1 = undefined
> = {
  200: t.Type<A0, C0>;
  403: t.Type<A1, C1>;
};

export function testAuthBearerDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = undefined,
  C1 = undefined
>(
  overrideTypes:
    | Partial<TestAuthBearerResponsesT<A0, C0, A1, C1>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  r.IResponseType<200, A0, never> | r.IResponseType<403, A1, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d[\\"_A\\"] !== \\"undefined\\";

  const type = {
    ...((testAuthBearerDefaultResponses as unknown) as TestAuthBearerResponsesT<
      A0,
      C0,
      A1,
      C1
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200][\\"_A\\"],
        typeof type[200][\\"_O\\"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d403 = (type[403].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 403, never>(403, undefined)
    : r.ioResponseDecoder<
        403,
        typeof type[403][\\"_A\\"],
        typeof type[403][\\"_O\\"],
        never
      >(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A1, never>>;

  return r.composeResponseDecoders(d200, d403);
}

// Decodes the success response with the type defined in the specs
export const testAuthBearerDefaultDecoder = () => testAuthBearerDecoder();

/****************************************************************
 * testFileUpload
 */

// Request type definition
export type TestFileUploadT = r.IPostApiRequestType<
  { readonly file: { uri: string; name: string; type: string } },
  \\"Content-Type\\",
  never,
  r.IResponseType<200, undefined, never>
>;

export const testFileUploadDefaultResponses = {
  200: t.undefined
};

export type TestFileUploadResponsesT<A0 = undefined, C0 = undefined> = {
  200: t.Type<A0, C0>;
};

export function testFileUploadDecoder<A0 = undefined, C0 = undefined>(
  overrideTypes:
    | Partial<TestFileUploadResponsesT<A0, C0>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<r.IResponseType<200, A0, never>> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d[\\"_A\\"] !== \\"undefined\\";

  const type = {
    ...((testFileUploadDefaultResponses as unknown) as TestFileUploadResponsesT<
      A0,
      C0
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200][\\"_A\\"],
        typeof type[200][\\"_O\\"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  return d200;
}

// Decodes the success response with the type defined in the specs
export const testFileUploadDefaultDecoder = () => testFileUploadDecoder();
"
`;

exports[`gen-api-models should generate a type intersection from allOf: all-of-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

// required attributes
const AllOfTest1R = t.interface({});

// optional attributes
const AllOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfTest1 = t.intersection(
  [AllOfTest1R, AllOfTest1O],
  \\"AllOfTest1\\"
);

export type AllOfTest1 = t.TypeOf<typeof AllOfTest1>;

export const AllOfTest = t.intersection(
  [AllOfTest1, PaginationResponse],
  \\"AllOfTest\\"
);

export type AllOfTest = t.TypeOf<typeof AllOfTest>;
"
`;

exports[`gen-api-models should generate a type union from allOf when x-one-of is used: allofoneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

/**
 * test if we can use allOf as oneOf
 */

// required attributes
const AllOfOneOfTest1R = t.interface({});

// optional attributes
const AllOfOneOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfOneOfTest1 = t.intersection(
  [AllOfOneOfTest1R, AllOfOneOfTest1O],
  \\"AllOfOneOfTest1\\"
);

export type AllOfOneOfTest1 = t.TypeOf<typeof AllOfOneOfTest1>;

export const AllOfOneOfTest = t.union(
  [AllOfOneOfTest1, PaginationResponse],
  \\"AllOfOneOfTest\\"
);

export type AllOfOneOfTest = t.TypeOf<typeof AllOfOneOfTest>;
"
`;

exports[`gen-api-models should generate a type union from oneOf: oneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// required attributes
const OneOfTest1R = t.interface({});

// optional attributes
const OneOfTest1O = t.partial({
  limited: t.boolean
});

export const OneOfTest1 = t.intersection(
  [OneOfTest1R, OneOfTest1O],
  \\"OneOfTest1\\"
);

export type OneOfTest1 = t.TypeOf<typeof OneOfTest1>;

// required attributes
const OneOfTest2R = t.interface({});

// optional attributes
const OneOfTest2O = t.partial({
  unlimited: t.boolean
});

export const OneOfTest2 = t.intersection(
  [OneOfTest2R, OneOfTest2O],
  \\"OneOfTest2\\"
);

export type OneOfTest2 = t.TypeOf<typeof OneOfTest2>;

export const OneOfTest = t.union([OneOfTest1, OneOfTest2], \\"OneOfTest\\");

export type OneOfTest = t.TypeOf<typeof OneOfTest>;
"
`;

exports[`gen-api-models should generate the operator definition 1`] = `
"
    /****************************************************************
     * testAuthBearer
     */

    // Request type definition
    export type TestAuthBearerT = r.IGetApiRequestType<{readonly bearerToken: string,readonly qo?: string,readonly qr: string,readonly cursor?: string}, \\"Authorization\\", never, r.IResponseType<200, undefined, never>|r.IResponseType<403, undefined, never>>;
  
      
    export const testAuthBearerDefaultResponses = {
      200: t.undefined, 403: t.undefined
    };
  
      
    export type TestAuthBearerResponsesT<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined> = {
      200: t.Type<A0, C0>, 403: t.Type<A1, C1>
    };
  
      export function testAuthBearerDecoder<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestAuthBearerResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<403, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testAuthBearerDefaultResponses as unknown as TestAuthBearerResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
    const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403, never>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"], never>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A1, never>>;
  
        return r.composeResponseDecoders(d200, d403)
      }

      // Decodes the success response with the type defined in the specs
      export const testAuthBearerDefaultDecoder = () => testAuthBearerDecoder();"
`;

exports[`gen-api-models should handle CustomStringFormats: custom-string-format 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { SomeCustomStringType as SomeCustomStringTypeT } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type CustomStringFormatTest = t.TypeOf<typeof CustomStringFormatTest>;
export const CustomStringFormatTest = SomeCustomStringTypeT;
"
`;

exports[`gen-api-models should handle NonNegativeIntegers: non-negative-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { NonNegativeInteger } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeIntegerTest = t.TypeOf<typeof NonNegativeIntegerTest>;
export const NonNegativeIntegerTest = NonNegativeInteger;
"
`;

exports[`gen-api-models should handle NonNegativeNumbers: non-negative-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { NonNegativeNumber } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeNumberTest = t.TypeOf<typeof NonNegativeNumberTest>;
export const NonNegativeNumberTest = NonNegativeNumber;
"
`;

exports[`gen-api-models should handle WithinRangeIntegers: within-range-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeInteger } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeIntegerTest = t.TypeOf<typeof WithinRangeIntegerTest>;
export const WithinRangeIntegerTest = WithinRangeInteger(0, 11);
"
`;

exports[`gen-api-models should handle WithinRangeNumbers: within-range-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeNumber } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeNumberTest = t.TypeOf<typeof WithinRangeNumberTest>;
export const WithinRangeNumberTest = WithinRangeNumber(0, 10);
"
`;

exports[`gen-api-models should handle WithinRangeStrings: within-range-strings 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeString } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type WithinRangeStringTest = t.TypeOf<typeof WithinRangeStringTest>;
export const WithinRangeStringTest = WithinRangeString(10, 11);
"
`;

exports[`gen-api-models should handle enums: enum-simple 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { enumType } from \\"italia-ts-commons/lib/types\\";

export enum StatusEnum {
  \\"value1\\" = \\"value1\\",

  \\"value2\\" = \\"value2\\",

  \\"value3\\" = \\"value3\\"
}

// required attributes
const EnumTestR = t.interface({});

// optional attributes
const EnumTestO = t.partial({
  status: enumType<StatusEnum>(StatusEnum, \\"status\\")
});

export const EnumTest = t.intersection([EnumTestR, EnumTestO], \\"EnumTest\\");

export type EnumTest = t.TypeOf<typeof EnumTest>;
"
`;

exports[`gen-api-models should include aliases for types already defined elsewhere if they have a different name: defined-type 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { OrganizationFiscalCode as OrganizationFiscalCodeT } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type OrganizationFiscalCodeTest = t.TypeOf<
  typeof OrganizationFiscalCodeTest
>;
export const OrganizationFiscalCodeTest = OrganizationFiscalCodeT;
"
`;

exports[`gen-api-models should not generate duplicate imports: dup-imports 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { EmailAddress } from \\"./EmailAddress\\";
import { FiscalCode } from \\"./FiscalCode\\";
import { IsInboxEnabled } from \\"./IsInboxEnabled\\";
import { IsWebhookEnabled } from \\"./IsWebhookEnabled\\";
import { PreferredLanguages } from \\"./PreferredLanguages\\";
import * as t from \\"io-ts\\";

/**
 * Describes the user's profile.
 */

// required attributes
const ProfilePayloadR = t.interface({});

// optional attributes
const ProfilePayloadO = t.partial({});

export const ProfilePayload = t.intersection(
  [ProfilePayloadR, ProfilePayloadO],
  \\"ProfilePayload\\"
);

export type ProfilePayload = t.TypeOf<typeof ProfilePayload>;

// required attributes
const ProfileR = t.interface({
  family_name: t.string,

  fiscal_code: FiscalCode,

  has_profile: t.boolean,

  is_email_set: t.boolean,

  name: t.string,

  version: t.Integer
});

// optional attributes
const ProfileO = t.partial({
  email: EmailAddress,

  is_inbox_enabled: IsInboxEnabled,

  is_webhook_enabled: IsWebhookEnabled,

  preferred_email: EmailAddress,

  preferred_languages: PreferredLanguages,

  payload: ProfilePayload
});

export const Profile = t.intersection([ProfileR, ProfileO], \\"Profile\\");

export type Profile = t.TypeOf<typeof Profile>;
"
`;

exports[`gen-api-models should parse custom inline properties: inline-property 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { PatternString } from \\"italia-ts-commons/lib/strings\\";

// required attributes
const InlinePropertyTestR = t.interface({});

// optional attributes
const InlinePropertyTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const InlinePropertyTest = t.intersection(
  [InlinePropertyTestR, InlinePropertyTestO],
  \\"InlinePropertyTest\\"
);

export type InlinePropertyTest = t.TypeOf<typeof InlinePropertyTest>;
"
`;

exports[`gen-api-models should parse nested objects: nested-object 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { PatternString } from \\"italia-ts-commons/lib/strings\\";

// required attributes
const NestedObjectTestNestedObjectR = t.interface({});

// optional attributes
const NestedObjectTestNestedObjectO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const NestedObjectTestNestedObject = t.intersection(
  [NestedObjectTestNestedObjectR, NestedObjectTestNestedObjectO],
  \\"NestedObjectTestNestedObject\\"
);

export type NestedObjectTestNestedObject = t.TypeOf<
  typeof NestedObjectTestNestedObject
>;

// required attributes
const NestedObjectTestR = t.interface({});

// optional attributes
const NestedObjectTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  ),

  nestedObject: NestedObjectTestNestedObject
});

export const NestedObjectTest = t.intersection(
  [NestedObjectTestR, NestedObjectTestO],
  \\"NestedObjectTest\\"
);

export type NestedObjectTest = t.TypeOf<typeof NestedObjectTest>;
"
`;

exports[`gen-api-models should render a client 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import {
  RequestParams,
  TypeofApiCall,
  TypeofApiParams,
  createFetchRequestForApi,
  ReplaceRequestParams
} from \\"italia-ts-commons/lib/requests\\";
import { identity } from \\"fp-ts/lib/function\\";

import {
  TestAuthBearerT,
  testAuthBearerDefaultDecoder,
  TestMultipleSuccessT,
  testMultipleSuccessDefaultDecoder,
  TestFileUploadT,
  testFileUploadDefaultDecoder,
  TestResponseHeaderT,
  testResponseHeaderDefaultDecoder,
  TestParameterWithReferenceT,
  testParameterWithReferenceDefaultDecoder
} from \\"./requestTypes\\";

// This is a placeholder for undefined when dealing with object keys
// Typescript doesn't perform well when narrowing a union type which includes string and undefined
// (example: \\"foo\\" | \\"bar\\" | undefined)
// We use this as a placeholder for type parameters indicating \\"no key\\"
type __UNDEFINED_KEY = \\"_____\\";

export type ApiOperation = TypeofApiCall<TestAuthBearerT> &
  TypeofApiCall<TestMultipleSuccessT> &
  TypeofApiCall<TestFileUploadT> &
  TypeofApiCall<TestResponseHeaderT> &
  TypeofApiCall<TestParameterWithReferenceT>;

export type ParamKeys = keyof (TypeofApiParams<TestAuthBearerT> &
  TypeofApiParams<TestMultipleSuccessT> &
  TypeofApiParams<TestFileUploadT> &
  TypeofApiParams<TestResponseHeaderT> &
  TypeofApiParams<TestParameterWithReferenceT>);

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type OmitApiCallParams<
  ApiT,
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = (
  op: TypeofApiCall<ApiT>
) => K extends __UNDEFINED_KEY
  ? TypeofApiCall<ApiT>
  : TypeofApiCall<ReplaceRequestParams<ApiT, Omit<RequestParams<ApiT>, K>>>;

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type WithDefaultsT<
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = OmitApiCallParams<
  | TestAuthBearerT
  | TestMultipleSuccessT
  | TestFileUploadT
  | TestResponseHeaderT
  | TestParameterWithReferenceT,
  K
>;

/**
 * Defines a collection of api operations
 * @param K name of the parameters that the Clients masks from the operations
 */
export type Client<
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = K extends __UNDEFINED_KEY
  ? {
      readonly testAuthBearer: TypeofApiCall<TestAuthBearerT>;

      readonly testMultipleSuccess: TypeofApiCall<TestMultipleSuccessT>;

      readonly testFileUpload: TypeofApiCall<TestFileUploadT>;

      readonly testResponseHeader: TypeofApiCall<TestResponseHeaderT>;

      readonly testParameterWithReference: TypeofApiCall<
        TestParameterWithReferenceT
      >;
    }
  : {
      readonly testAuthBearer: TypeofApiCall<
        ReplaceRequestParams<
          TestAuthBearerT,
          Omit<RequestParams<TestAuthBearerT>, K>
        >
      >;

      readonly testMultipleSuccess: TypeofApiCall<
        ReplaceRequestParams<
          TestMultipleSuccessT,
          Omit<RequestParams<TestMultipleSuccessT>, K>
        >
      >;

      readonly testFileUpload: TypeofApiCall<
        ReplaceRequestParams<
          TestFileUploadT,
          Omit<RequestParams<TestFileUploadT>, K>
        >
      >;

      readonly testResponseHeader: TypeofApiCall<
        ReplaceRequestParams<
          TestResponseHeaderT,
          Omit<RequestParams<TestResponseHeaderT>, K>
        >
      >;

      readonly testParameterWithReference: TypeofApiCall<
        ReplaceRequestParams<
          TestParameterWithReferenceT,
          Omit<RequestParams<TestParameterWithReferenceT>, K>
        >
      >;
    };

/**
 * Create an instance of a client
 * @param params hash map of parameters thata define the client:
 *  - baseUrl: the base url for every api call (required)
 *  - fetchApi: an implementation of the fetch() web API, depending on the platform (required)
 *  - basePath: optional path to be appended to the baseUrl
 *  - withDefaults: optional adapter to be applied to every operation, to omit some paramenters
 * @returns a collection of api operations
 */
export function createClient<K extends ParamKeys>(params: {
  baseUrl: string;
  // tslint:disable-next-line:no-any
  fetchApi: typeof fetch;
  withDefaults: WithDefaultsT<K>;
  basePath?: string;
}): Client<K>;
export function createClient(params: {
  baseUrl: string;
  // tslint:disable-next-line:no-any
  fetchApi: typeof fetch;
  withDefaults?: undefined;
  basePath?: string;
}): Client;
export function createClient<K extends ParamKeys>({
  baseUrl,
  // tslint:disable-next-line:no-any
  fetchApi,
  withDefaults,
  basePath = \\"/api/v1\\"
}: {
  baseUrl: string;
  // tslint:disable-next-line:no-any
  fetchApi: typeof fetch;
  withDefaults?: WithDefaultsT<K>;
  basePath?: string;
}) {
  const options = {
    baseUrl,
    fetchApi
  };

  const testAuthBearerT: ReplaceRequestParams<
    TestAuthBearerT,
    RequestParams<TestAuthBearerT>
  > = {
    method: \\"get\\",

    headers: ({ bearerToken }: { bearerToken: string }) => ({
      Authorization: \`Bearer \${bearerToken}\`
    }),
    response_decoder: testAuthBearerDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-auth-bearer\`,

    query: ({ qo, qr, cursor }) => ({ qo, qr, cursor })
  };
  const testAuthBearer: TypeofApiCall<TestAuthBearerT> = createFetchRequestForApi(
    testAuthBearerT,
    options
  );

  const testMultipleSuccessT: ReplaceRequestParams<
    TestMultipleSuccessT,
    RequestParams<TestMultipleSuccessT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testMultipleSuccessDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-multiple-success\`,

    query: () => ({})
  };
  const testMultipleSuccess: TypeofApiCall<TestMultipleSuccessT> = createFetchRequestForApi(
    testMultipleSuccessT,
    options
  );

  const testFileUploadT: ReplaceRequestParams<
    TestFileUploadT,
    RequestParams<TestFileUploadT>
  > = {
    method: \\"post\\",

    headers: () => ({
      \\"Content-Type\\": \\"multipart/form-data\\"
    }),
    response_decoder: testFileUploadDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-file-upload\`,

    body: ({ file }) => file.uri,

    query: () => ({})
  };
  const testFileUpload: TypeofApiCall<TestFileUploadT> = createFetchRequestForApi(
    testFileUploadT,
    options
  );

  const testResponseHeaderT: ReplaceRequestParams<
    TestResponseHeaderT,
    RequestParams<TestResponseHeaderT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testResponseHeaderDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-response-header\`,

    query: () => ({})
  };
  const testResponseHeader: TypeofApiCall<TestResponseHeaderT> = createFetchRequestForApi(
    testResponseHeaderT,
    options
  );

  const testParameterWithReferenceT: ReplaceRequestParams<
    TestParameterWithReferenceT,
    RequestParams<TestParameterWithReferenceT>
  > = {
    method: \\"post\\",

    headers: () => ({
      \\"Content-Type\\": \\"application/json\\"
    }),
    response_decoder: testParameterWithReferenceDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-parameter-with-reference\`,

    body: ({ createdMessage }) => JSON.stringify(createdMessage),

    query: () => ({})
  };
  const testParameterWithReference: TypeofApiCall<TestParameterWithReferenceT> = createFetchRequestForApi(
    testParameterWithReferenceT,
    options
  );

  return {
    testAuthBearer: (withDefaults || identity)(testAuthBearer),
    testMultipleSuccess: (withDefaults || identity)(testMultipleSuccess),
    testFileUpload: (withDefaults || identity)(testFileUpload),
    testResponseHeader: (withDefaults || identity)(testResponseHeader),
    testParameterWithReference: (withDefaults || identity)(
      testParameterWithReference
    )
  };
}
"
`;

exports[`gen-api-models should support additionalProperties default value: additional-properties-default 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { withDefault } from \\"italia-ts-commons/lib/types\\";

type AdditionalpropsDefaultBase = t.TypeOf<typeof AdditionalpropsDefaultBase>;
const AdditionalpropsDefaultBase = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalpropsDefault\\"
);

// additional attributes

export const AdditionalpropsDefault = withDefault(AdditionalpropsDefaultBase, {
  test: [1000]
} as AdditionalpropsDefaultBase);

export type AdditionalpropsDefault = t.TypeOf<typeof AdditionalpropsDefault>;
"
`;

exports[`gen-api-models should support file uploads 1`] = `
"
    /****************************************************************
     * testFileUpload
     */

    // Request type definition
    export type TestFileUploadT = r.IPostApiRequestType<{readonly file: { uri: string, name: string, type: string }}, \\"Content-Type\\", never, r.IResponseType<200, undefined, never>>;
  
      
    export const testFileUploadDefaultResponses = {
      200: t.undefined
    };
  
      
    export type TestFileUploadResponsesT<A0 = undefined, C0 = undefined> = {
      200: t.Type<A0, C0>
    };
  
      export function testFileUploadDecoder<A0 = undefined, C0 = undefined>(overrideTypes: Partial<TestFileUploadResponsesT<A0, C0>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testFileUploadDefaultResponses as unknown as TestFileUploadResponsesT<A0, C0>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
        return d200
      }

      // Decodes the success response with the type defined in the specs
      export const testFileUploadDefaultDecoder = () => testFileUploadDecoder();"
`;

exports[`gen-api-models should support headers in response 1`] = `
"
    /****************************************************************
     * testResponseHeader
     */

    // Request type definition
    export type TestResponseHeaderT = r.IGetApiRequestType<{}, never, never, r.IResponseType<201, Message, \\"Location\\" | \\"Id\\">|r.IResponseType<500, undefined, never>>;
  
      
    export const testResponseHeaderDefaultResponses = {
      201: Message, 500: t.undefined
    };
  
      
    export type TestResponseHeaderResponsesT<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined> = {
      201: t.Type<A0, C0>, 500: t.Type<A1, C1>
    };
  
      export function testResponseHeaderDecoder<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestResponseHeaderResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<201, A0, \\"Location\\" | \\"Id\\">|r.IResponseType<500, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testResponseHeaderDefaultResponses as unknown as TestResponseHeaderResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
        };

        
    const d201 = (type[201].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 201, \\"Location\\" | \\"Id\\">(201, undefined) 
        : r.ioResponseDecoder<201, (typeof type[201])[\\"_A\\"], (typeof type[201])[\\"_O\\"], \\"Location\\" | \\"Id\\">(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, \\"Location\\" | \\"Id\\">>;
  
    const d500 = (type[500].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 500, never>(500, undefined) 
        : r.ioResponseDecoder<500, (typeof type[500])[\\"_A\\"], (typeof type[500])[\\"_O\\"], never>(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A1, never>>;
  
        return r.composeResponseDecoders(d201, d500)
      }

      // Decodes the success response with the type defined in the specs
      export const testResponseHeaderDefaultDecoder = () => testResponseHeaderDecoder();"
`;

exports[`gen-api-models should support multiple success cases 1`] = `
"
    /****************************************************************
     * testMultipleSuccess
     */

    // Request type definition
    export type TestMultipleSuccessT = r.IGetApiRequestType<{}, never, never, r.IResponseType<200, Message, never>|r.IResponseType<202, undefined, never>|r.IResponseType<403, OneOfTest, never>|r.IResponseType<404, undefined, never>>;
  
      
    export const testMultipleSuccessDefaultResponses = {
      200: Message, 202: t.undefined, 403: OneOfTest, 404: t.undefined
    };
  
      
    export type TestMultipleSuccessResponsesT<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined> = {
      200: t.Type<A0, C0>, 202: t.Type<A1, C1>, 403: t.Type<A2, C2>, 404: t.Type<A3, C3>
    };
  
      export function testMultipleSuccessDecoder<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined>(overrideTypes: Partial<TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<202, A1, never>|r.IResponseType<403, A2, never>|r.IResponseType<404, A3, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testMultipleSuccessDefaultResponses as unknown as TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
    const d202 = (type[202].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 202, never>(202, undefined) 
        : r.ioResponseDecoder<202, (typeof type[202])[\\"_A\\"], (typeof type[202])[\\"_O\\"], never>(202, type[202])) as r.ResponseDecoder<r.IResponseType<202, A1, never>>;
  
    const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403, never>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"], never>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A2, never>>;
  
    const d404 = (type[404].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 404, never>(404, undefined) 
        : r.ioResponseDecoder<404, (typeof type[404])[\\"_A\\"], (typeof type[404])[\\"_O\\"], never>(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;
  
        return r.composeResponseDecoders(r.composeResponseDecoders(r.composeResponseDecoders(d200, d202), d403), d404)
      }

      // Decodes the success response with the type defined in the specs
      export const testMultipleSuccessDefaultDecoder = () => testMultipleSuccessDecoder();"
`;
